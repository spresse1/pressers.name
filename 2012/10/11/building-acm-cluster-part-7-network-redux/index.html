<!doctype html><html lang=en><head><title>Building the ACM Cluster, Part 7: Network redux - The Electronic Press</title><meta charset=utf-8><meta http-equiv=cache-control content="public"><meta name=robots content="follow, all"><meta name=language content="en"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="So I&rsquo;ve mentioned that I&rsquo;ve been fighting networking again in the ACM cluster. I&rsquo;ve been reworking the network. This whole adventure began after a conversation with the very knowledgeable nwf, who pointed out that JHU runs two different networks that the ACM systems need access to - CSNet (the JHU Computer Science department&rsquo;s network) and JHU firewall-free (which has unfiltered access to the internet). The goal of this rework was to allow the cluster to be on both."><meta name=keywords content><link rel=alternate type=application/rss+xml title="RSS Feed for pressers.name" href=/index.xml><link rel=stylesheet type=text/css media="screen, projection" href=/static/css/base.css><link rel=stylesheet type=text/css media="screen, projection" href=/static/css/cssmenu.css><link rel=stylesheet type=text/css media="screen, projection" href=/static/css/menustyling.css><link rel=stylesheet type=text/css media="screen, projection" href=/static/css/blog.css><link rel=stylesheet type=text/css media=print href=/static/css/print.css></head><body><div id=skip><a href=#content>Skip to Main Content</a></div><div id=leftbar></div><div id=contentwrapper><div id=header><div id=titleimagediv></div><div id=twotraces><div id=twotracesright>&nbsp;</div></div></div><div class=menu id=topmenu><nav><ul class=top-navigation><li><a href=/ title=Home rel=home>Home</a></li><li><a href=http://github.com/spresse1>GitHub</a></li><li><a href=/contact>Contact</a></li></ul></nav></div><div id=onetrace><div id=onetraceleft></div><div id=breadcrumbs class=breadcrumbs><nav><ul class=breadcrumbs><li><a href=/>Home</a></li><li><a href=/blog/>Blogs</a></li><li><a href=/2012/10/11/building-acm-cluster-part-7-network-redux/>Building the ACM Cluster, Part 7: Network redux</a></li></ul></nav></div></div><div id=bodywrapper><div id=content><div id=contentborder></div><div id=innercontent><main><div class=hentry><article itemtype=http://schema.org/Article itemscope id=blog/acm-cluster/building-acm-cluster-part-7-network-redux.md><header class=entry-header><h1 class=entry-title><a href=/2012/10/11/building-acm-cluster-part-7-network-redux/>Building the ACM Cluster, Part 7: Network redux</a></h1><p class=entry-info>Published on <time>Thu, Oct 11, 2012</time>
in ACM, ACM Cluster</p></header><div class=entry-body><p>So I&rsquo;ve mentioned that I&rsquo;ve been fighting networking again in the ACM cluster.  I&rsquo;ve been reworking the network.  This whole adventure began after a conversation with the very knowledgeable <a href=https://www.ietfng.org/nwf/>nwf</a>, who pointed out that JHU runs two different networks that the ACM systems need access to - CSNet (the JHU Computer Science department&rsquo;s network) and JHU firewall-free (which has unfiltered access to the internet).  The goal of this rework was to allow the cluster to be on both.  In a situation with more resources, I would have simply bought another network card for each of the gateway nodes.  However, I don&rsquo;t have those resources and couldn&rsquo;t find any spare network cards.  nwf then pointed out that I would be able to use 802.1Q vlans to make more virtual ports.</p><p>So, here&rsquo;s how this works:  CSNet and JHU firewall-free (JHUFF) each plug into a single port on the main switches.  These ports are assigned as being on specific vlans that differ from the other ports on the switch.  The gateway nodes are trunked, which means that they see the raw traffic - that is, they get packets with the 802.1Q vlan tags intact.  (Typically, switches remove these tags before they pass packets through the ports).  In my case, I&rsquo;ve got the gateway nodes bonded into the switch, in order to double their bandwidth.  In this context, bonded means that the server can send a message through either interface in order to (roughly) double the bandwidth.  The rest of the ports on the switch are then left on the default vlan.</p><p>If you think pictures work better, take a look at this one: <a href=/static/images/ACMCluster/NetworkLayout/Switch12DetailWithVLANs.png>ACM Cluster Network Diagram</a>.</p><h1 id=switch-setup>Switch Setup</h1><p>Fortunately, the switch setup is fairly simple.  We simply add the following (in my case) to the configuration file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>interface FastEthernet0/1
</span></span><span style=display:flex><span> switchport access vlan <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>!
</span></span><span style=display:flex><span>interface FastEthernet0/2
</span></span><span style=display:flex><span> switchport access vlan <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>!
</span></span><span style=display:flex><span>interface FastEthernet0/3
</span></span><span style=display:flex><span> switchport trunk encapsulation dot1q
</span></span><span style=display:flex><span> switchport mode trunk
</span></span></code></pre></div><p>Note that those last 3 lines are repeated for any port that is being directed to a gateway server.   In this case, port 1 is the JHUFF.  I&rsquo;ve marked it as on vlan2.  Port 2 is JHUCS, on vlan3.  Note that vlan1 is the default vlan, so I&rsquo;ve left that unassigned to the &ldquo;special&rdquo; ports.  This way I don&rsquo;t have to explicitly assign anything to any port which should &lsquo;just work&rsquo;.</p><p>At this point, the switch is not quite all set, but I&rsquo;ll leave the configuration of that part until later.  After I tell you how I messed up my upstream network(s) the first time I was setting this up.</p><h1 id=gateway-server-setup>Gateway Server Setup</h1><p>The gateway node setup comes in two steps.  First, bonding the interfaces together, then creating virtual interfaces to get vlan traffic.  I highly recommend you do this on a local or otherwise not network-dependent console, because if things are just slightly wrong&mldr; you&rsquo;ll need physical locality to fix them.</p><h2 id=bonding-interfaces>Bonding interfaces</h2><p>Bonding linux interfaces is a fairly common task - It just makes the two interfaces present to userland as one interface and allows the kernel to pick which of the two (or more) physical interfaces to send out of.  It is used for a number of purposes - higher bandwidth and redundancy, for example.</p><p>Creating bonded interfaces in CentOS is pretty easy.  First, lets create the configuration file for bond0 (our bonded interface):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ sane-editor /etc/sysconfig/network-scripts/ifcfg-bond0
</span></span></code></pre></div><p>And make the file look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>DEVICE<span style=color:#f92672>=</span>bond0 
</span></span><span style=display:flex><span>BOOTPROTO<span style=color:#f92672>=</span>none 
</span></span><span style=display:flex><span>ONBOOT<span style=color:#f92672>=</span>yes
</span></span><span style=display:flex><span>USERCTL<span style=color:#f92672>=</span>no
</span></span></code></pre></div><p>Next, we need to slave eth0 and eth1 to bond0.  For purposes of brevity, I&rsquo;m only going to show you eth0&rsquo;s configuration.  I&rsquo;ve bolded the parts that will need changing in eth1.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>DEVICE<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;**eth0**&#34;</span>
</span></span><span style=display:flex><span>BOOTPROTO<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;none&#34;</span>
</span></span><span style=display:flex><span>ONBOOT<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;yes&#34;</span>
</span></span><span style=display:flex><span>MASTER<span style=color:#f92672>=</span>bond0
</span></span><span style=display:flex><span>SLAVE<span style=color:#f92672>=</span>yes
</span></span><span style=display:flex><span>USERCTL<span style=color:#f92672>=</span>no
</span></span></code></pre></div><p>Again, repeat this for every interface you&rsquo;d like to be a slave of bond0.  Restart networking by running</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># service network restart</span>
</span></span></code></pre></div><p>and check that bond0 came up ok.</p><p>In my case, the CentOS boot scripts also would not bring up the interface unless the bonding module was explicitly loaded.  In order to do this, run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># echo modprobe bonding &gt;&gt; /etc/rc.modules</span>
</span></span><span style=display:flex><span><span style=color:#75715e># chmod +x /etc/rc.modules</span>
</span></span></code></pre></div><p>Note that if you explicitly assign an IP address (or other startup mode, like DHCP) to bond0 (which I have not done, because it shouldn&rsquo;t have one), you most likely will not need to do this.</p><h1 id=enabling-vlan-specific-interfaces>Enabling VLAN-Specific interfaces</h1><p>Okay, now we need to actually have the gateway server separate traffic out by vlan so we can run services on only specific vlans.  We do this because some services (DHCP, NFS, DNS) should not be externally exposed.  As with the bonded interface, we&rsquo;ll create these interfaces by editing files.  To create an interface that goes directly to vlan1, create <code>/etc/sysconfig/network-scripts/ifcfg-bond0.1</code> and put the following in it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>DEVICE<span style=color:#f92672>=</span>bond0.1
</span></span><span style=display:flex><span>BOOTPROTO<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;none&#34;</span>
</span></span><span style=display:flex><span>ONBOOT<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;yes&#34;</span>
</span></span><span style=display:flex><span>TYPE<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Ethernet&#34;</span>
</span></span><span style=display:flex><span>USERCTL<span style=color:#f92672>=</span>no
</span></span><span style=display:flex><span>VLAN<span style=color:#f92672>=</span>yes
</span></span></code></pre></div><p>Yes, theres some magic here - the system intuits the vlan you&rsquo;re interested in from the number I&rsquo;ve bolded above.  If you change that (and the name of the file), you&rsquo;ll create a interface that is tied to that vlan.</p><h1 id=problems-and-solutions>Problems (and Solutions)</h1><p>If you&rsquo;ve been paying attention here, you&rsquo;ll see a problem with this setup.  In this case, bond0, in non-promiscuous mode, reflects vlan1.  But, in promiscuous mode, you can see traffic for all vlans.  The problem is that DHCP must be promiscuous so it can see DHCP requests.  Unfortunately, this means that it is impossible to listen only on the native vlan for DHCP requests.  In my case this is very bad, since the other vlans already have DHCP servers and running mine on these vlans would interfere with these.</p><p>In fact, I did this by accident.  When I first started this up, I ran it on the bond0 interface.  Unfortunately, this started responding to DHCP requests on CSNet.  The CS sysadmins very quickly hunted me down and asked me to shut it down, as it was preventing their machines from properly DHCPing.</p><p>There are two possible solutions to this problem: change the native vlan that we get from the port and create an interface that specifically can only get the native vlan&rsquo;s traffic.</p><h2 id=changing-the-native-vlan>Changing the native VLAN</h2><p>This solution will not work if you have the Cisco switches I have.  However, if you have sane switches, give this a shot first - its much simpler.  The basic idea is to force your switch to vlan tag the traffic going over the trunk.  In my case, this was accomplished by adding the line</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> switchport trunk native vlan XX
</span></span></code></pre></div><p>to the interface configuration options for the ports going to the gateway servers.  (XX represents an otherwise unused vlan).  By doing this, you can run your DHCP server on the interface that is specifically yours.  DHCP requests from the other vlans will not reach it, since the operating system strips these out before they reach the server.</p><h3 id=down-the-rabbit-hole>Down the Rabbit Hole</h3><p>However! Here I started running into problems.  My switches wouldn&rsquo;t DHCP anymore.  After much frustration, I broke out my best friend in network debugging, wireshark, and took a look.  After isolating the right packets, this is what I saw:</p><p><a href=/static/images/ACMCluster/WiresharkOfCiscoNoGoodDHCP.png><img src=/static/images/ACMCluster/WiresharkOfCiscoNoGoodDHCP.png alt="Screenshot of WireShark showing bad DHCP packets"></a></p><p>(Click to enbiggen - <a href=/static/other/ACMCluster/CiscoC2900XLDHCPAttemptViaVLAN.cap>Download this capture</a>)</p><p>See that bright bar of red?  That indicates that WireShark believes this packet is malformed.  See the lack of responses?  That sealed the deal for me - these packets are malformed!  And badly!</p><p>In order to verify that this was actually a deformed packet, I went back to an older configuration where DHCP was sent without vlan tags by the switch.  Turns out that in this case, yes, the DHCP packets are properly formed if they are not vlan-tagged.</p><p>Well. Crud.  I cannot use non-vlan tagged packets because then I&rsquo;d be answering on CSNet again.  So because of this bug, this method is totally unsuitable for me.  However, if your switches do not exhibit this bug, it ought to work quite well and be quite simple to set up.</p><h2 id=creating-a-pseudo-vlan-interface>Creating a pseudo-vlan interface</h2><p>This method is one I&rsquo;ve built explicitly to work around the bug I just detailed.  In order to do this, we&rsquo;re going to use <a href=http://ebtables.sourceforge.net/>ebtables</a>, which does layer2 filtering of packets.  This means that it operates at the same level as ethernet and vlan tagging - just what we need!</p><h3 id=set-up-bridged-interface>Set up Bridged Interface</h3><p>Ebtables is designed to filter traffic crossing a bridge.  In this case, since we&rsquo;re the endpoint, we&rsquo;re doing something dumb: setting up a bridged interface with only one end point.  So lets get started.  Create <code>/etc/sysconfig/network-scripts/ifcfg-bond0.def</code>.  Bond0.def is my name for the interface that gets only default vlan traffic that enters on bond0.  Feel free to change the name to something else you think is more useful or clear.  Anyway, make the contents of that file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>DEVICE<span style=color:#f92672>=</span>bond0.def
</span></span><span style=display:flex><span>TYPE<span style=color:#f92672>=</span>bridge
</span></span><span style=display:flex><span>BOOTPROTO<span style=color:#f92672>=</span>none
</span></span><span style=display:flex><span>ONBOOT<span style=color:#f92672>=</span>yes
</span></span><span style=display:flex><span>NETWORK<span style=color:#f92672>=</span>172.16.0.0
</span></span><span style=display:flex><span>NETMASK<span style=color:#f92672>=</span>255.240.0.0
</span></span><span style=display:flex><span>IPADDR<span style=color:#f92672>=</span>172.16.0.2
</span></span></code></pre></div><p>You&rsquo;ll note I&rsquo;ve also set an IP address here.  Since this interface represents the gateway node to the default vlan, it ought to have an IP address.</p><p>We also need to change <code>/etc/sysconfig/network-scripts/ifcfg-bond0</code> to contain the line:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>BRIDGE<span style=color:#f92672>=</span>bond0.def
</span></span></code></pre></div><p>And restart networking:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># service networking restart</span>
</span></span></code></pre></div><p>Hopefully everything comes up okay, in which case, move on to the next step.</p><p>Here what we just did:  By slaving bond0 under bond0.def, we&rsquo;ve ensured that anything listening or sending on the bond0.def interface can see all traffic on bond0.  So whats left is limiting the traffic that bond0.def can see to only non-vlaned traffic.</p><h3 id=set-up-ebtables>Set up ebtables</h3><p>We&rsquo;ll be using ebtables to limit the traffic to bond0.def.  First, lets install ebtables:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># yum install ebtables</span>
</span></span></code></pre></div><p>Next, set up the ebtables rule that will drop all vlaned traffic:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># ebtables -A OUTPUT -p 802_1Q -o bond0.def -j DROP</span>
</span></span></code></pre></div><p>Then save the rule:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># service ebtables save</span>
</span></span></code></pre></div><p>And finally, lets make ebtables start on boot (and start it right now):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># chkconfig --level 2345 ebtables on</span>
</span></span><span style=display:flex><span><span style=color:#75715e># service ebtables start</span>
</span></span></code></pre></div><p>And that&rsquo;s it!  This ebtables rule looks for any 802.1Q traffic (via -p (for protocol)) destined for bond0.def (the -o, for output, flag) and drops it (-j DROP).  I cannot promise this is the most efficient way to do it, but it certainly works.</p><h1 id=one-more-problem>One More Problem&mldr;</h1><p>So even after all of this, my switches are not DHCPing properly.  I&rsquo;ve done the Wiresharking, and it looks like the switches simply don&rsquo;t accept the DHCP response.  Since this worked before I introduced the vlans, I can only conclude that DHCP on these switches (which yes, are running the latest version of the software) is broken if vlans are enabled.  This conclusion is further backed by the fact that the DHCP requests are <strong>still</strong> malformed.</p><p>At this point I need to give up on completely on dynamic configuration.  There are simply too many bugs in Cisco&rsquo;s firmware and I&rsquo;ve spent too much time working around them.  I&rsquo;m choosing to, in my instance, stay with the bond0.def setup.  I feel like this is a cleaner setup than hacking around inside the switch.</p><p>So. The solution I&rsquo;m going with to configure the switches is to write the configuration to NVRAM.  You&rsquo;ll probably want to write at least your basic vlan numbering to the switch&rsquo;s NVRAM.  Otherwise, before the switch DHCPs, it will pass all traffic on all interfaces through untagged.  Which could wreck havoc while the switch finds its configuration.  Oh, and I cover building this configuration a little further down in this article.</p><p>There are a couple of ways to get the configuration onto the NVRAM.  The first is to do the configuration on the switch.  This is the way configuration like this is typically done.  I&rsquo;m going to pass on this because I&rsquo;d like to have some central repository of all my configuration.  This leaves transfer via tftp and via xmodem.  </p><h2 id=xmodem>Xmodem</h2><p>Xmodem transfer is done via serial cable.  I use minicom, since it is easily capable of doing this.  Start up minicom on the device connected to the switch (usually <code>/dev/ttyS0</code>).  Then run the following on the switch:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; enable
</span></span><span style=display:flex><span><span style=color:#75715e># copy xmodem: flash:config.text</span>
</span></span></code></pre></div><p>At this point, press control-A, then S.  Then select your configuration file and send it.  I&rsquo;ve had cases where I had to restart minicom to get this to work.  No I don&rsquo;t know why.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># reload</span>
</span></span></code></pre></div><p>The switch reboots and will come up with your new configuration.</p><h2 id=tftp-transfer>TFTP Transfer</h2><p>TFTP is really convenient for updating configuration over the network.  However, it requires that your switch be properly talking to the network.  If thats not the case, you&rsquo;ll have to use xmodem transfer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; enable
</span></span><span style=display:flex><span><span style=color:#75715e># copy tftp://[tftp server]/[config file] flash:config.text</span>
</span></span></code></pre></div><p>At this point, the file transfers.  Now reboot the switch:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># reload</span>
</span></span></code></pre></div><h1 id=final-embedded-configuration>Final Embedded Configuration</h1><p>Okay, now lets run through the final configuration that I&rsquo;ve uploaded to the switches.  I&rsquo;m going to run through it piece by piece.  So lets get started with the generic header junk:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>!
</span></span><span style=display:flex><span>version 12.0
</span></span><span style=display:flex><span>no service pad
</span></span><span style=display:flex><span>service timestamps debug uptime
</span></span><span style=display:flex><span>service timestamps log uptime
</span></span><span style=display:flex><span>no service password-encryption
</span></span></code></pre></div><p>Nothing interesting here, so lets move on:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>!
</span></span><span style=display:flex><span>hostname eth-switch1
</span></span><span style=display:flex><span>!
</span></span><span style=display:flex><span>enable password <span style=color:#f92672>[</span>password<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>!
</span></span></code></pre></div><p>The first part of this sets the hostname you&rsquo;ll see when you log in.  The second sets the password you&rsquo;ll need to input to enable privileged commands on the switch.</p><p>Next, interface configuration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>interface FastEthernet0/1
</span></span><span style=display:flex><span> switchport access vlan <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>!
</span></span><span style=display:flex><span>interface FastEthernet0/2
</span></span><span style=display:flex><span> switchport access vlan <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>!
</span></span><span style=display:flex><span>interface FastEthernet0/3
</span></span><span style=display:flex><span> port group <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span> switchport mode trunk
</span></span><span style=display:flex><span> switchport trunk encapsulation dot1q
</span></span><span style=display:flex><span> switchport trunk allowed vlan all
</span></span><span style=display:flex><span>!
</span></span><span style=display:flex><span>interface FastEthernet0/4
</span></span><span style=display:flex><span> port group <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span> switchport mode trunk
</span></span><span style=display:flex><span> switchport trunk encapsulation dot1q
</span></span><span style=display:flex><span> switchport trunk allowed vlan all
</span></span><span style=display:flex><span>!
</span></span><span style=display:flex><span>interface FastEthernet0/5
</span></span><span style=display:flex><span> switchport mode trunk
</span></span><span style=display:flex><span> switchport trunk encapsulation dot1q
</span></span><span style=display:flex><span> switchport trunk allowed vlan all
</span></span><span style=display:flex><span>!
</span></span><span style=display:flex><span>interface FastEthernet0/6
</span></span><span style=display:flex><span> switchport mode trunk
</span></span><span style=display:flex><span> switchport trunk encapsulation dot1q
</span></span><span style=display:flex><span> switchport trunk allowed vlan all
</span></span><span style=display:flex><span>!
</span></span></code></pre></div><p>Okay, lots here, but it should be fairly simple to walk through all of it.  As I mentioned at the very beginning FastEthernet 0/1 and 0/2 go to our upstream connections.  To segregate them from the rest of the network, I put them on vlan 2 and vlan 3 respectively.  <code>switchport access vlan X</code> is the Cisco configuration command to put a port on a specific vlan.</p><p>Next, FastEtherenet 0/3 and 0/4.  These are the trunked lines from this top switch to the secondary switch. <code>port group 1</code> tells the switch that these two ports go together and traffic needs to be sent to only one of the two.  The next three lines turn this into a trunked interface that receives all vlans.</p><p>FastEtherenet 0/5 and 0/6 are the same as 0/3 and 0/4, except that they&rsquo;re not grouped, since they run to the primary and secondary master/gateway nodes.</p><p>The next section deals with SNMP setup.  (Remember that?  Its how the master node can find out who a new node should be).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ip default-gateway 172.16.0.1
</span></span><span style=display:flex><span>snmp-server engineID local 0000000902000002B99420C0
</span></span><span style=display:flex><span>snmp-server community public view v1default RO
</span></span><span style=display:flex><span>snmp-server chassis-id 0x0E
</span></span><span style=display:flex><span>snmp-server host 172.16.0.1 trap public  entity snmp
</span></span><span style=display:flex><span>!
</span></span></code></pre></div><p>This instructs the switch that it should send SNMP traps to 172.16.0.1 whenever a new machine connects to it.</p><p>Now, some final cleanup stuff:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>enable secret <span style=color:#ae81ff>5</span> <span style=color:#f92672>[</span>encrypted password<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>!
</span></span><span style=display:flex><span>line con <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span> transport input none
</span></span><span style=display:flex><span> stopbits <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>line vty <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>password <span style=color:#f92672>[</span>password<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span> login
</span></span><span style=display:flex><span>!
</span></span><span style=display:flex><span>end
</span></span></code></pre></div><p>These deal primarily with access passwords.  Simply consider them magic.  I do - I configured a switch with the right passwords and then ran</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Switch# show running-config
</span></span></code></pre></div><p>to get these lines.</p><h1 id=conclusion>Conclusion</h1><p>Well, here ends my great networking adventure.  This should bring to a close my work with the ethernet network layer in the cluster.  At some point I will have to play with the fiber network, but that should be simpler.  We&rsquo;ll get to that at some point&mldr;</p><p>Anyway, some lessons learned:</p><ul><li>Make sure whatever software you&rsquo;re using has a way to report bugs and ask for bugfixes</li><li>Simple is good</li><li>Sometimes things don&rsquo;t work exactly as one would hope</li></ul><p>Anyway, after 2+ weeks of spending my spare time fighting this issue, it is time for me to move on and try to get the nodes functioning.  So that&rsquo;s where I&rsquo;m headed next!</p></div></article></div></main></div></div><div id=sidebar><div class=widget><nav><h1>Recent Posts</h1><ul class=entries-reent><li><a href=https://pressers.name/2022/02/01/enigma-2022/>Enigma 2022</a></li><li><a href=https://pressers.name/2021/11/21/getting-new-lenses-lensfun-notes/>Getting new lenses for Lensfun</a></li><li><a href=https://pressers.name/2021/10/04/living-germany-converting-drivers-license/>Living in Germany: Converting a Driver's License</a></li><li><a href=https://pressers.name/2021/02/08/im-moving-germany/>I'm moving to Germany!</a></li><li><a href=https://pressers.name/2021/01/23/i-finally-finished-kings-quest-6/>I Finally Finished King's Quest 6!</a></li></ul></nav></div><div class=sidebarbender></div><div class=widget><nav><h1>Social Media</h1><ul class=socialmedia><li><a href=https://twitter.com/spresser>Twitter</a></li><li><a href=https://www.linkedin.com/in/steven-presser/>LinkedIn</a></li></ul></nav></div><div class=sidebarbender></div><div class=widget><nav><h1>Categories</h1><ul class=categories><li><a href=https://pressers.name/categories/3d-printing/>3D Printing</a></li><li><a href=https://pressers.name/categories/acm/>ACM</a></li><li><a href=https://pressers.name/categories/acm-cluster/>ACM Cluster</a></li><li><a href=https://pressers.name/categories/cyberlaw/>Cyberlaw</a></li><li><a href=https://pressers.name/categories/cybersecurity/>Cybersecurity</a></li><li><a href=https://pressers.name/categories/germany/>Germany</a></li><li><a href=https://pressers.name/categories/infrastructure/>Infrastructure</a></li><li><a href=https://pressers.name/categories/life-in-germany/>Life in Germany</a></li><li><a href=https://pressers.name/categories/links/>Links</a></li><li><a href=https://pressers.name/categories/presentations/>Presentations</a></li><li><a href=https://pressers.name/categories/projects/>Projects</a></li><li><a href=https://pressers.name/categories/shrubbery/>Shrubbery</a></li></ul></nav></div><div class=sidebarbender></div></div></div><div id=onetracebottom><footer><a href=https://github.com/spresse1/pressers.name>Website source</a><br>Site design by Kyle M.</footer></div></div></body></html>